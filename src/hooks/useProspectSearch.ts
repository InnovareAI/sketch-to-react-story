// React hooks for Prospect Search functionality
// Generated by Supabase Database Agent

import { useState, useEffect, useCallback } from 'react';
import { ProspectSearchService } from '@/services/prospect-search';
import {
  SearchConfiguration,
  ProspectProfile,
  SearchHistory,
  CsvUploadSession,
  ProspectCampaignAssignment,
  EnrichmentQueue,
  CreateSearchConfigurationRequest,
  ExecuteSearchRequest,
  ExecuteSearchResponse,
  UploadCsvRequest,
  UploadCsvResponse,
  ProcessCsvRequest,
  ProcessCsvResponse,
  AssignProspectsToCampaignRequest,
  AssignProspectsToCampaignResponse,
  BulkEnrichProspectsRequest,
  BulkEnrichProspectsResponse,
  ProspectSearchFilters,
  SearchConfigurationFilters,
  PaginationParams,
  PaginatedResponse,
  CsvValidationError,
  SearchType,
  SearchMethod
} from '@/types/prospect-search';

// ============================================================================
// SEARCH CONFIGURATIONS HOOK
// ============================================================================

export function useSearchConfigurations(workspaceId: string) {
  const [configurations, setConfigurations] = useState<SearchConfiguration[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchConfigurations = useCallback(async (
    filters?: SearchConfigurationFilters,
    pagination?: PaginationParams
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getSearchConfigurations(
        workspaceId,
        filters,
        pagination
      );
      
      setConfigurations(result.data);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch search configurations';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  const createConfiguration = useCallback(async (
    request: CreateSearchConfigurationRequest,
    userId: string
  ) => {
    try {
      const newConfig = await ProspectSearchService.createSearchConfiguration(
        request,
        workspaceId,
        userId
      );
      
      setConfigurations(prev => [newConfig, ...prev]);
      return newConfig;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create search configuration';
      setError(errorMessage);
      throw err;
    }
  }, [workspaceId]);

  const updateConfiguration = useCallback(async (
    id: string,
    updates: Partial<SearchConfiguration>
  ) => {
    try {
      const updatedConfig = await ProspectSearchService.updateSearchConfiguration(id, updates);
      
      setConfigurations(prev => 
        prev.map(config => config.id === id ? updatedConfig : config)
      );
      
      return updatedConfig;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update search configuration';
      setError(errorMessage);
      throw err;
    }
  }, []);

  const deleteConfiguration = useCallback(async (id: string) => {
    try {
      await ProspectSearchService.deleteSearchConfiguration(id);
      setConfigurations(prev => prev.filter(config => config.id !== id));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to delete search configuration';
      setError(errorMessage);
      throw err;
    }
  }, []);

  // Load configurations on mount
  useEffect(() => {
    fetchConfigurations();
  }, [fetchConfigurations]);

  return {
    configurations,
    loading,
    error,
    fetchConfigurations,
    createConfiguration,
    updateConfiguration,
    deleteConfiguration
  };
}

// ============================================================================
// PROSPECT PROFILES HOOK
// ============================================================================

export function useProspectProfiles(workspaceId: string) {
  const [prospects, setProspects] = useState<ProspectProfile[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchProspects = useCallback(async (
    filters?: ProspectSearchFilters,
    pagination?: PaginationParams
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getProspectProfiles(
        workspaceId,
        filters,
        pagination
      );
      
      setProspects(result.data);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch prospects';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  const createProspect = useCallback(async (prospect: any) => {
    try {
      const newProspect = await ProspectSearchService.createProspectProfile({
        ...prospect,
        workspace_id: workspaceId
      });
      
      setProspects(prev => [newProspect, ...prev]);
      return newProspect;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create prospect';
      setError(errorMessage);
      throw err;
    }
  }, [workspaceId]);

  const bulkCreateProspects = useCallback(async (
    prospects: any[],
    checkDuplicates = true
  ) => {
    try {
      const prospectsWithWorkspace = prospects.map(p => ({
        ...p,
        workspace_id: workspaceId
      }));
      
      const result = await ProspectSearchService.bulkCreateProspectProfiles(
        prospectsWithWorkspace,
        checkDuplicates
      );
      
      // Add created prospects to state
      if (result.created.length > 0) {
        setProspects(prev => [...result.created, ...prev]);
      }
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to bulk create prospects';
      setError(errorMessage);
      throw err;
    }
  }, [workspaceId]);

  const updateProspect = useCallback(async (
    id: string,
    updates: Partial<ProspectProfile>
  ) => {
    try {
      const updatedProspect = await ProspectSearchService.updateProspectProfile(id, updates);
      
      setProspects(prev => 
        prev.map(prospect => prospect.id === id ? updatedProspect : prospect)
      );
      
      return updatedProspect;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update prospect';
      setError(errorMessage);
      throw err;
    }
  }, []);

  // Load prospects on mount
  useEffect(() => {
    fetchProspects();
  }, [fetchProspects]);

  return {
    prospects,
    loading,
    error,
    fetchProspects,
    createProspect,
    bulkCreateProspects,
    updateProspect
  };
}

// ============================================================================
// SEARCH EXECUTION HOOK
// ============================================================================

export function useSearchExecution() {
  const [isSearching, setIsSearching] = useState(false);
  const [searchError, setSearchError] = useState<string | null>(null);
  const [searchResult, setSearchResult] = useState<ExecuteSearchResponse | null>(null);

  const executeSearch = useCallback(async (request: ExecuteSearchRequest & {
    searchUrl?: string;
    brightDataOptions?: any;
  }) => {
    try {
      setIsSearching(true);
      setSearchError(null);
      
      const result = await ProspectSearchService.executeSearch(request);
      setSearchResult(result);
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to execute search';
      setSearchError(errorMessage);
      throw err;
    } finally {
      setIsSearching(false);
    }
  }, []);

  const resetSearch = useCallback(() => {
    setSearchResult(null);
    setSearchError(null);
    setIsSearching(false);
  }, []);

  return {
    isSearching,
    searchError,
    searchResult,
    executeSearch,
    resetSearch
  };
}

// ============================================================================
// SEARCH HISTORY HOOK
// ============================================================================

export function useSearchHistory(workspaceId: string) {
  const [history, setHistory] = useState<SearchHistory[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchHistory = useCallback(async (
    searchConfigId?: string,
    pagination?: PaginationParams
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getSearchHistory(
        workspaceId,
        searchConfigId,
        pagination
      );
      
      setHistory(result.data);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch search history';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  // Load history on mount
  useEffect(() => {
    fetchHistory();
  }, [fetchHistory]);

  return {
    history,
    loading,
    error,
    fetchHistory
  };
}

// ============================================================================
// CSV UPLOAD HOOK
// ============================================================================

export function useCsvUpload(workspaceId: string, userId: string) {
  const [uploadSession, setUploadSession] = useState<CsvUploadSession | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [validationErrors, setValidationErrors] = useState<CsvValidationError[]>([]);
  const [error, setError] = useState<string | null>(null);

  const createUploadSession = useCallback(async (request: UploadCsvRequest) => {
    try {
      setIsUploading(true);
      setError(null);
      
      const result = await ProspectSearchService.createCsvUploadSession(
        request,
        workspaceId,
        userId
      );
      
      if (result.status === 'created' && result.session_id) {
        const session = await ProspectSearchService.getCsvUploadSession(result.session_id);
        setUploadSession(session);
      }
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create CSV upload session';
      setError(errorMessage);
      throw err;
    } finally {
      setIsUploading(false);
    }
  }, [workspaceId, userId]);

  const processUpload = useCallback(async (request: ProcessCsvRequest) => {
    try {
      setIsProcessing(true);
      setError(null);
      
      const result = await ProspectSearchService.processCsvUpload(request);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to process CSV upload';
      setError(errorMessage);
      throw err;
    } finally {
      setIsProcessing(false);
    }
  }, []);

  const validateCsvData = useCallback((
    data: any[],
    fieldMappings: Record<string, string>
  ) => {
    const validation = ProspectSearchService.validateCsvData(data, fieldMappings);
    setValidationErrors(validation.errors);
    return validation;
  }, []);

  const resetUploadSession = useCallback(() => {
    setUploadSession(null);
    setValidationErrors([]);
    setError(null);
    setIsUploading(false);
    setIsProcessing(false);
  }, []);

  return {
    uploadSession,
    isUploading,
    isProcessing,
    validationErrors,
    error,
    createUploadSession,
    processUpload,
    validateCsvData,
    resetUploadSession
  };
}

// ============================================================================
// CAMPAIGN ASSIGNMENTS HOOK
// ============================================================================

export function useCampaignAssignments(workspaceId: string, userId: string) {
  const [assignments, setAssignments] = useState<ProspectCampaignAssignment[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const assignProspectsToCampaign = useCallback(async (
    request: AssignProspectsToCampaignRequest
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.assignProspectsToCampaign(
        request,
        workspaceId,
        userId
      );
      
      // Refresh assignments after successful assignment
      await fetchAssignments();
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to assign prospects to campaign';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId, userId]);

  const fetchAssignments = useCallback(async (
    campaignId?: string,
    prospectId?: string,
    pagination?: PaginationParams
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getProspectCampaignAssignments(
        workspaceId,
        campaignId,
        prospectId,
        pagination
      );
      
      setAssignments(result.data);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch campaign assignments';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  return {
    assignments,
    loading,
    error,
    assignProspectsToCampaign,
    fetchAssignments
  };
}

// ============================================================================
// ENRICHMENT HOOK
// ============================================================================

export function useEnrichment(workspaceId: string) {
  const [enrichmentQueue, setEnrichmentQueue] = useState<EnrichmentQueue[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const bulkEnrichProspects = useCallback(async (request: BulkEnrichProspectsRequest) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.bulkEnrichProspects(request, workspaceId);
      
      // Refresh queue after successful enrichment request
      await fetchEnrichmentQueue();
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to bulk enrich prospects';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  const fetchEnrichmentQueue = useCallback(async (
    status?: string,
    pagination?: PaginationParams
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getEnrichmentQueue(
        workspaceId,
        status,
        pagination
      );
      
      setEnrichmentQueue(result.data);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch enrichment queue';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  return {
    enrichmentQueue,
    loading,
    error,
    bulkEnrichProspects,
    fetchEnrichmentQueue
  };
}

// ============================================================================
// BRIGHT DATA ANALYTICS HOOK
// ============================================================================

export function useBrightDataAnalytics(workspaceId: string) {
  const [analytics, setAnalytics] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchAnalytics = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getBrightDataAnalytics(workspaceId);
      setAnalytics(result);
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch Bright Data analytics';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [workspaceId]);

  const updateConfig = useCallback(async (config: {
    monthly_budget?: number;
    requests_per_minute?: number;
    requests_per_hour?: number;
    alert_threshold?: number;
  }) => {
    try {
      setError(null);
      await ProspectSearchService.updateBrightDataConfig(config);
      
      // Refresh analytics after config update
      await fetchAnalytics();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update Bright Data config';
      setError(errorMessage);
      throw err;
    }
  }, [fetchAnalytics]);

  const cancelSearch = useCallback(async (
    searchId: string,
    searchHistoryId: string
  ) => {
    try {
      setError(null);
      const result = await ProspectSearchService.cancelBrightDataSearch(
        searchId,
        searchHistoryId
      );
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to cancel search';
      setError(errorMessage);
      throw err;
    }
  }, []);

  return {
    analytics,
    loading,
    error,
    fetchAnalytics,
    updateConfig,
    cancelSearch
  };
}

// ============================================================================
// SEARCH STATUS HOOK
// ============================================================================

export function useSearchStatus(
  searchHistoryId: string,
  brightDataSearchId?: string
) {
  const [status, setStatus] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchStatus = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await ProspectSearchService.getSearchStatus(
        searchHistoryId,
        brightDataSearchId
      );
      
      setStatus(result);
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch search status';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [searchHistoryId, brightDataSearchId]);

  // Auto-refresh status for active searches
  useEffect(() => {
    if (!searchHistoryId) return;

    const interval = setInterval(() => {
      if (status?.overall_status === 'active') {
        fetchStatus();
      }
    }, 5000); // Poll every 5 seconds for active searches

    return () => clearInterval(interval);
  }, [searchHistoryId, status?.overall_status, fetchStatus]);

  return {
    status,
    loading,
    error,
    fetchStatus
  };
}

// ============================================================================
// COMBINED HOOK FOR COMPLEX OPERATIONS
// ============================================================================

export function useProspectSearchWorkflow(workspaceId: string, userId: string) {
  const searchConfigs = useSearchConfigurations(workspaceId);
  const prospects = useProspectProfiles(workspaceId);
  const searchExecution = useSearchExecution();
  const searchHistory = useSearchHistory(workspaceId);
  const csvUpload = useCsvUpload(workspaceId, userId);
  const campaignAssignments = useCampaignAssignments(workspaceId, userId);
  const enrichment = useEnrichment(workspaceId);
  const brightDataAnalytics = useBrightDataAnalytics(workspaceId);

  return {
    searchConfigs,
    prospects,
    searchExecution,
    searchHistory,
    csvUpload,
    campaignAssignments,
    enrichment,
    brightDataAnalytics
  };
}