// LinkedIn Integration Manager
// Orchestrates all LinkedIn search types with Bright Data, n8n, and optimization

import { toast } from 'sonner';
import { supabase } from '@/integrations/supabase/client';
import { enhancedBrightDataService } from '@/services/brightdata-proxy-secure';
import { ProspectSearchService } from '@/services/prospect-search';
import { ProspectSearchOptimizer } from '@/services/prospect-search-optimizer';
import { N8nProspectWorkflows } from '@/services/n8n-prospect-workflows';
import { n8nService } from '@/services/n8n/N8nIntegrationService';

export interface LinkedInSearchRequest {
  searchType: 'basic-search' | 'sales-navigator' | 'recruiter-search' | 'company-follower' | 'post-engagement' | 'group-search' | 'event-search' | 'people-you-know';
  searchUrl?: string;
  workspaceId: string;
  userId: string;
  campaignId?: string;
  options: {
    maxResults?: number;
    country?: string;
    linkedInAccountId?: string;
    filters?: {
      location?: string[];
      industry?: string[];
      currentCompany?: string[];
      jobTitle?: string[];
      connectionDegree?: number[];
    };
  };
}

export interface LinkedInSearchResponse {
  success: boolean;
  searchId: string;
  searchHistoryId: string;
  estimatedCost: number;
  estimatedResults: number;
  budgetStatus: 'ok' | 'warning' | 'exceeded';
  message: string;
  recommendations?: string[];
  error?: string;
}

export interface SearchProgress {
  searchId: string;
  status: 'starting' | 'running' | 'processing' | 'completed' | 'failed' | 'cancelled';
  progress: number; // 0-100
  currentStep: string;
  resultsFound: number;
  estimatedCompletion: string;
  costSoFar: number;
  errors: string[];
}

export class LinkedInIntegrationManager {
  private static activeSearches = new Map<string, SearchProgress>();
  private static searchCallbacks = new Map<string, (progress: SearchProgress) => void>();

  /**
   * Execute any LinkedIn search type with full optimization and error handling
   */
  static async executeLinkedInSearch(request: LinkedInSearchRequest): Promise<LinkedInSearchResponse> {
    const searchId = `linkedin_search_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    try {
      // 1. Pre-flight checks
      const preflightResult = await this.performPreflightChecks(request);
      if (!preflightResult.success) {
        return {
          success: false,
          searchId,
          searchHistoryId: '',
          estimatedCost: 0,
          estimatedResults: 0,
          budgetStatus: 'exceeded',
          message: preflightResult.error!,
          error: preflightResult.error
        };
      }
      
      // 2. Optimize search parameters
      const optimization = await ProspectSearchOptimizer.optimizeSearchParameters(
        request.searchType,
        request.options.maxResults || 50,
        5.00 // $5 budget
      );
      
      // 3. Create search configuration
      const searchConfig = await ProspectSearchService.createSearchConfiguration(
        {\n          name: `${request.searchType} - ${new Date().toISOString()}`,\n          search_type: request.searchType as any,\n          search_method: 'url-search' as any,\n          parameters: {\n            search_url: request.searchUrl,\n            max_results: optimization.optimized_params.max_results,\n            proxy_regions: optimization.optimized_params.proxy_regions,\n            ...request.options\n          },\n          filters: request.options.filters || {}\n        },\n        request.workspaceId,\n        request.userId\n      );\n      \n      // 4. Initialize search progress tracking\n      const searchProgress: SearchProgress = {\n        searchId,\n        status: 'starting',\n        progress: 0,\n        currentStep: 'Initializing search...',\n        resultsFound: 0,\n        estimatedCompletion: new Date(Date.now() + 5 * 60 * 1000).toISOString(), // 5 min estimate\n        costSoFar: 0,\n        errors: []\n      };\n      \n      this.activeSearches.set(searchId, searchProgress);\n      \n      // 5. Execute search with retry logic\n      const searchExecution = await ProspectSearchOptimizer.executeWithRetry(\n        async () => {\n          return await this.executeSearchByType(request, searchConfig.id, searchId);\n        },\n        {\n          search_type: request.searchType,\n          search_id: searchId\n        }\n      );\n      \n      // 6. Process and return response\n      const response: LinkedInSearchResponse = {\n        success: true,\n        searchId,\n        searchHistoryId: searchExecution.searchHistoryId,\n        estimatedCost: optimization.optimized_params.estimated_cost,\n        estimatedResults: optimization.optimized_params.max_results,\n        budgetStatus: searchExecution.budgetStatus,\n        message: `${request.searchType} search started successfully`,\n        recommendations: optimization.recommendations.map(r => r.action)\n      };\n      \n      // Update progress\n      searchProgress.status = 'running';\n      searchProgress.progress = 25;\n      searchProgress.currentStep = 'Scraping LinkedIn data...';\n      this.updateSearchProgress(searchId, searchProgress);\n      \n      return response;\n      \n    } catch (error) {\n      // Update progress with error\n      const searchProgress = this.activeSearches.get(searchId);\n      if (searchProgress) {\n        searchProgress.status = 'failed';\n        searchProgress.errors.push(error instanceof Error ? error.message : 'Unknown error');\n        this.updateSearchProgress(searchId, searchProgress);\n      }\n      \n      return {\n        success: false,\n        searchId,\n        searchHistoryId: '',\n        estimatedCost: 0,\n        estimatedResults: 0,\n        budgetStatus: 'ok',\n        message: 'Search execution failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n  \n  /**\n   * Perform pre-flight checks before executing search\n   */\n  private static async performPreflightChecks(\n    request: LinkedInSearchRequest\n  ): Promise<{ success: boolean; error?: string }> {\n    // Check budget status\n    const analytics = await enhancedBrightDataService.getUsageAnalytics();\n    if (analytics.monthly_summary.budget_utilization >= 1.0) {\n      return { success: false, error: 'Monthly budget exceeded. Cannot execute new searches.' };\n    }\n    \n    // Validate search URL format for URL-based searches\n    if (request.searchUrl && !request.searchUrl.includes('linkedin.com')) {\n      return { success: false, error: 'Invalid LinkedIn URL format' };\n    }\n    \n    // Check for required LinkedIn account for certain search types\n    if (['sales-navigator', 'recruiter-search', 'people-you-know'].includes(request.searchType)) {\n      if (!request.options.linkedInAccountId) {\n        return { success: false, error: `${request.searchType} requires a connected LinkedIn account` };\n      }\n    }\n    \n    // Check maximum results limits\n    const maxLimits: Record<string, number> = {\n      'basic-search': 100,\n      'sales-navigator': 25,\n      'recruiter-search': 25,\n      'company-follower': 500,\n      'post-engagement': 200,\n      'group-search': 500,\n      'event-search': 300,\n      'people-you-know': 50\n    };\n    \n    if (request.options.maxResults && request.options.maxResults > maxLimits[request.searchType]) {\n      return {\n        success: false,\n        error: `Maximum ${maxLimits[request.searchType]} results allowed for ${request.searchType}`\n      };\n    }\n    \n    return { success: true };\n  }\n  \n  /**\n   * Execute search based on specific type\n   */\n  private static async executeSearchByType(\n    request: LinkedInSearchRequest,\n    searchConfigId: string,\n    searchId: string\n  ): Promise<{ searchHistoryId: string; budgetStatus: 'ok' | 'warning' | 'exceeded' }> {\n    const searchProgress = this.activeSearches.get(searchId)!;\n    \n    try {\n      switch (request.searchType) {\n        case 'basic-search':\n          searchProgress.currentStep = 'Executing LinkedIn basic search...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          const basicResult = await enhancedBrightDataService.executeLinkedInBasicSearch(\n            request.searchUrl!,\n            {\n              maxResults: request.options.maxResults || 50,\n              country: request.options.country,\n              workspaceId: request.workspaceId,\n              searchConfigId,\n              filters: request.options.filters\n            }\n          );\n          \n          searchProgress.progress = 75;\n          searchProgress.resultsFound = basicResult.results.length;\n          searchProgress.costSoFar = basicResult.cost_info.estimated_cost;\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          break;\n          \n        case 'sales-navigator':\n          searchProgress.currentStep = 'Executing Sales Navigator search...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          await enhancedBrightDataService.executeLinkedInSalesNavigatorSearch(\n            request.searchUrl!,\n            {\n              maxResults: request.options.maxResults || 25,\n              country: request.options.country,\n              workspaceId: request.workspaceId,\n              searchConfigId\n            }\n          );\n          break;\n          \n        case 'company-follower':\n          searchProgress.currentStep = 'Scraping company followers...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          await enhancedBrightDataService.scrapeCompanyFollowers(\n            request.searchUrl!,\n            {\n              maxFollowers: request.options.maxResults || 200,\n              workspaceId: request.workspaceId,\n              searchConfigId,\n              filters: {\n                location: request.options.filters?.location,\n                jobTitle: request.options.filters?.jobTitle\n              }\n            }\n          );\n          break;\n          \n        case 'post-engagement':\n          searchProgress.currentStep = 'Analyzing post engagement...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          await enhancedBrightDataService.scrapePostEngagement(\n            request.searchUrl!,\n            {\n              maxEngagers: request.options.maxResults || 100,\n              workspaceId: request.workspaceId,\n              searchConfigId,\n              engagementTypes: ['like', 'comment', 'share']\n            }\n          );\n          break;\n          \n        case 'group-search':\n          searchProgress.currentStep = 'Extracting group members...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          await enhancedBrightDataService.scrapeGroupMembers(\n            request.searchUrl!,\n            {\n              maxMembers: request.options.maxResults || 500,\n              workspaceId: request.workspaceId,\n              searchConfigId\n            }\n          );\n          break;\n          \n        case 'event-search':\n          searchProgress.currentStep = 'Finding event attendees...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          await enhancedBrightDataService.scrapeEventAttendees(\n            request.searchUrl!,\n            {\n              maxAttendees: request.options.maxResults || 300,\n              workspaceId: request.workspaceId,\n              searchConfigId,\n              attendanceTypes: ['attending', 'interested']\n            }\n          );\n          break;\n          \n        case 'people-you-know':\n          searchProgress.currentStep = 'Loading network suggestions...';\n          this.updateSearchProgress(searchId, searchProgress);\n          \n          await enhancedBrightDataService.scrapePeopleYouMayKnow({\n            maxSuggestions: request.options.maxResults || 50,\n            workspaceId: request.workspaceId,\n            searchConfigId,\n            linkedInAccountId: request.options.linkedInAccountId!\n          });\n          break;\n      }\n      \n      // Complete the search\n      searchProgress.status = 'completed';\n      searchProgress.progress = 100;\n      searchProgress.currentStep = 'Search completed successfully!';\n      this.updateSearchProgress(searchId, searchProgress);\n      \n      // Create mock search history ID for now\n      const searchHistoryId = `history_${Date.now()}`;\n      \n      return {\n        searchHistoryId,\n        budgetStatus: 'ok'\n      };\n      \n    } catch (error) {\n      searchProgress.status = 'failed';\n      searchProgress.errors.push(error instanceof Error ? error.message : 'Unknown error');\n      this.updateSearchProgress(searchId, searchProgress);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get real-time search progress\n   */\n  static getSearchProgress(searchId: string): SearchProgress | null {\n    return this.activeSearches.get(searchId) || null;\n  }\n  \n  /**\n   * Subscribe to search progress updates\n   */\n  static subscribeToSearchProgress(\n    searchId: string,\n    callback: (progress: SearchProgress) => void\n  ): () => void {\n    this.searchCallbacks.set(searchId, callback);\n    \n    // Return unsubscribe function\n    return () => {\n      this.searchCallbacks.delete(searchId);\n    };\n  }\n  \n  /**\n   * Cancel an active search\n   */\n  static async cancelSearch(searchId: string): Promise<{ success: boolean; error?: string }> {\n    const searchProgress = this.activeSearches.get(searchId);\n    \n    if (!searchProgress) {\n      return { success: false, error: 'Search not found' };\n    }\n    \n    if (searchProgress.status === 'completed' || searchProgress.status === 'failed') {\n      return { success: false, error: 'Search already completed' };\n    }\n    \n    try {\n      // Cancel with Bright Data service\n      const cancelResult = await enhancedBrightDataService.cancelSearch(searchId);\n      \n      if (cancelResult.success) {\n        searchProgress.status = 'cancelled';\n        searchProgress.currentStep = 'Search cancelled by user';\n        this.updateSearchProgress(searchId, searchProgress);\n        \n        // Clean up after a delay\n        setTimeout(() => {\n          this.activeSearches.delete(searchId);\n          this.searchCallbacks.delete(searchId);\n        }, 5000);\n      }\n      \n      return cancelResult;\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n  \n  /**\n   * Get all active searches\n   */\n  static getActiveSearches(): SearchProgress[] {\n    return Array.from(this.activeSearches.values());\n  }\n  \n  /**\n   * Update search progress and notify subscribers\n   */\n  private static updateSearchProgress(searchId: string, progress: SearchProgress): void {\n    this.activeSearches.set(searchId, progress);\n    \n    const callback = this.searchCallbacks.get(searchId);\n    if (callback) {\n      callback(progress);\n    }\n  }\n  \n  /**\n   * Get comprehensive analytics for LinkedIn integration\n   */\n  static async getLinkedInAnalytics(workspaceId: string): Promise<{\n    usage_summary: any;\n    cost_analysis: any;\n    performance_metrics: any;\n    recommendations: any[];\n    budget_status: {\n      current_spend: number;\n      monthly_budget: number;\n      utilization_percentage: number;\n      estimated_remaining_searches: number;\n    };\n  }> {\n    try {\n      // Get Bright Data analytics\n      const brightDataAnalytics = await enhancedBrightDataService.getUsageAnalytics();\n      \n      // Get performance analysis\n      const performanceAnalysis = await ProspectSearchOptimizer.analyzeSearchPerformance(\n        workspaceId,\n        {\n          from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(), // Last 30 days\n          to: new Date().toISOString()\n        }\n      );\n      \n      const budgetStatus = {\n        current_spend: brightDataAnalytics.cost_tracker.current_spend,\n        monthly_budget: brightDataAnalytics.cost_tracker.monthly_budget,\n        utilization_percentage: brightDataAnalytics.monthly_summary.budget_utilization * 100,\n        estimated_remaining_searches: Math.floor(\n          (brightDataAnalytics.cost_tracker.monthly_budget - brightDataAnalytics.cost_tracker.current_spend) /\n          Math.max(brightDataAnalytics.monthly_summary.average_cost_per_prospect, 0.01)\n        )\n      };\n      \n      return {\n        usage_summary: brightDataAnalytics.usage_stats,\n        cost_analysis: performanceAnalysis.cost_analysis,\n        performance_metrics: performanceAnalysis.performance_metrics,\n        recommendations: performanceAnalysis.recommendations,\n        budget_status: budgetStatus\n      };\n    } catch (error) {\n      console.error('Error getting LinkedIn analytics:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Setup complete LinkedIn integration for a workspace\n   */\n  static async setupWorkspaceIntegration(\n    workspaceId: string,\n    config: {\n      monthly_budget?: number;\n      n8n_api_url?: string;\n      n8n_api_key?: string;\n      linkedin_accounts?: string[];\n    }\n  ): Promise<{\n    success: boolean;\n    setup_summary: {\n      bright_data_configured: boolean;\n      n8n_workflows_deployed: number;\n      linkedin_accounts_connected: number;\n      total_setup_time: number;\n    };\n    errors: string[];\n  }> {\n    const setupStartTime = Date.now();\n    const errors: string[] = [];\n    let workflowsDeployed = 0;\n    \n    try {\n      // 1. Configure Bright Data budget\n      if (config.monthly_budget) {\n        await ProspectSearchService.updateBrightDataConfig({\n          monthly_budget: config.monthly_budget\n        });\n      }\n      \n      // 2. Deploy n8n workflows if API details provided\n      if (config.n8n_api_url && config.n8n_api_key) {\n        try {\n          const workflowSetup = await ProspectSearchService.setupN8nWorkflows(\n            workspaceId,\n            config.n8n_api_url,\n            config.n8n_api_key\n          );\n          workflowsDeployed = workflowSetup.deployed_workflows.length;\n          errors.push(...workflowSetup.errors);\n        } catch (error) {\n          errors.push(`n8n workflow deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n      }\n      \n      // 3. Setup LinkedIn account connections\n      let linkedInAccountsConnected = 0;\n      if (config.linkedin_accounts) {\n        for (const accountId of config.linkedin_accounts) {\n          try {\n            await supabase.from('linkedin_account_connections').upsert({\n              workspace_id: workspaceId,\n              account_id: accountId,\n              status: 'active',\n              connected_at: new Date().toISOString()\n            });\n            linkedInAccountsConnected++;\n          } catch (error) {\n            errors.push(`Failed to connect LinkedIn account ${accountId}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n          }\n        }\n      }\n      \n      const setupTime = Date.now() - setupStartTime;\n      \n      return {\n        success: errors.length === 0,\n        setup_summary: {\n          bright_data_configured: true,\n          n8n_workflows_deployed: workflowsDeployed,\n          linkedin_accounts_connected: linkedInAccountsConnected,\n          total_setup_time: setupTime\n        },\n        errors\n      };\n    } catch (error) {\n      console.error('Error setting up workspace integration:', error);\n      return {\n        success: false,\n        setup_summary: {\n          bright_data_configured: false,\n          n8n_workflows_deployed: 0,\n          linkedin_accounts_connected: 0,\n          total_setup_time: Date.now() - setupStartTime\n        },\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n}